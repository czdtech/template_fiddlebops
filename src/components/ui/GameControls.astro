---
import { getDeviceType } from "@/utils/mobile";
import type { GameConfig } from "@/config/types";

interface Props {
  config: GameConfig;
  className?: string;
}

const { config, className = "" } = Astro.props;
const deviceType = getDeviceType();
---

<div class={`game-controls ${className}`}>
  <!-- 方向建议提示 -->
  {
    config.orientation === "landscape" && deviceType !== "desktop" && (
      <div class="orientation-notice" data-orientation="portrait">
        <div class="notice-content">
          <svg class="rotate-icon" viewBox="0 0 24 24" width="48" height="48">
            <path
              fill="currentColor"
              d="M16.48 2.52c3.27 1.55 5.61 4.72 5.97 8.48h1.5C23.44 4.84 18.29 0 12 0l-.66.03 3.81 3.81 1.33-1.32zm-6.25-.77c-.59-.59-1.54-.59-2.12 0L1.75 8.11c-.59.59-.59 1.54 0 2.12l12.02 12.02c.59.59 1.54.59 2.12 0l6.36-6.36c.59-.59.59-1.54 0-2.12L10.23 1.75zm4.6 19.44L2.81 9.17l6.36-6.36 12.02 12.02-6.36 6.36zm-7.31.29C4.25 19.94 1.91 16.76 1.55 13H.05C.56 19.16 5.71 24 12 24l.66-.03-3.81-3.81-1.33 1.32z"
            />
          </svg>
          <p>建议旋转设备以获得更好的游戏体验</p>
          <div class="notice-actions">
            <button class="action-button rotate-action">旋转屏幕</button>
            <button class="action-button continue-action">继续当前方向</button>
          </div>
          <label class="remember-choice">
            <input type="checkbox" class="remember-checkbox" />
            记住我的选择
          </label>
        </div>
      </div>
    )
  }

  <!-- 游戏控制说明 -->
  <div class="controls-container">
    <div class="controls-grid">
      {
        deviceType === "desktop" ? (
          <div class="control-block">
            <h3>桌面端控制</h3>
            <ul>
              {config.controls.desktop.map((control) => (
                <li>{control}</li>
              ))}
            </ul>
          </div>
        ) : (
          <div class="control-block">
            <h3>移动端控制</h3>
            <ul>
              {config.controls.mobile.map((control) => (
                <li>{control}</li>
              ))}
            </ul>
          </div>
        )
      }
    </div>
  </div>

  <!-- 加载状态 -->
  <div class="loading-state" aria-live="polite">
    <p class="loading-text">{config.loading.message}</p>
    <div class="loading-progress">
      <div class="progress-bar"></div>
    </div>
  </div>
</div>

<style>
  .game-controls {
    position: relative;
    width: 100%;
    background: var(--color-background-lighter);
    border-radius: 0 0 1rem 1rem;
    overflow: hidden;
  }

  .orientation-notice {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.9);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    color: white;
    text-align: center;
    padding: 2rem;
  }

  .notice-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1rem;
  }

  .rotate-icon {
    animation: rotate 2s infinite linear;
  }

  @keyframes rotate {
    from {
      transform: rotate(0deg);
    }
    to {
      transform: rotate(360deg);
    }
  }

  .controls-container {
    padding: 1.5rem;
  }

  .controls-grid {
    display: grid;
    gap: 1rem;
  }

  .control-block {
    background: var(--color-background);
    padding: 1rem;
    border-radius: 0.5rem;
    border: 1px solid var(--color-border);
  }

  .control-block h3 {
    font-size: 1rem;
    margin-bottom: 0.5rem;
    color: var(--color-text);
  }

  .control-block ul {
    list-style: none;
    padding: 0;
  }

  .control-block li {
    position: relative;
    padding-left: 1.25rem;
    margin-bottom: 0.5rem;
    font-size: 0.875rem;
    line-height: 1.4;
    color: var(--color-text-muted);
  }

  .control-block li::before {
    content: "•";
    position: absolute;
    left: 0;
    color: var(--color-primary);
  }

  .loading-state {
    padding: 1rem;
    text-align: center;
    background: var(--color-background);
    border-top: 1px solid var(--color-border);
  }

  .loading-text {
    font-size: 0.875rem;
    color: var(--color-text-muted);
    margin-bottom: 0.5rem;
  }

  .loading-progress {
    width: 100%;
    height: 4px;
    background: var(--color-border);
    border-radius: 2px;
    overflow: hidden;
  }

  .progress-bar {
    width: 30%;
    height: 100%;
    background: var(--color-primary);
    border-radius: 2px;
    animation: progress 2s infinite ease-in-out;
  }

  @keyframes progress {
    0% {
      transform: translateX(-100%);
    }
    100% {
      transform: translateX(400%);
    }
  }

  @media (max-width: 768px) {
    .controls-container {
      padding: 1rem;
    }

    .control-block {
      padding: 0.75rem;
    }

    .control-block li {
      font-size: 0.8125rem;
    }
  }

  .notice-actions {
    display: flex;
    gap: 1rem;
    margin-top: 1rem;
  }

  .action-button {
    padding: 0.5rem 1rem;
    border: none;
    border-radius: 0.5rem;
    font-size: 0.875rem;
    cursor: pointer;
    transition: background-color 0.2s;
  }

  .rotate-action {
    background: var(--color-primary);
    color: white;
  }

  .continue-action {
    background: transparent;
    border: 1px solid white;
    color: white;
  }

  .remember-choice {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-top: 1rem;
    font-size: 0.75rem;
    color: var(--color-text-muted);
  }

  .remember-checkbox {
    width: 1rem;
    height: 1rem;
  }
</style>

<script>
  import {
    onOrientationChange,
    getDeviceOrientation,
    lockScreenOrientation,
  } from "@/utils/mobile";

  const ORIENTATION_PREFERENCE_KEY = "game-orientation-preference";
  const REMEMBER_PREFERENCE_KEY = "remember-orientation-choice";

  const orientationNotice = document.querySelector(
    ".orientation-notice"
  ) as HTMLElement;
  if (orientationNotice) {
    const rotateButton = orientationNotice.querySelector(".rotate-action");
    const continueButton = orientationNotice.querySelector(".continue-action");
    const rememberChoice = orientationNotice.querySelector(
      ".remember-checkbox"
    ) as HTMLInputElement;

    // 检查用户之前的选择
    const savedPreference = localStorage.getItem(ORIENTATION_PREFERENCE_KEY);
    const shouldRemember =
      localStorage.getItem(REMEMBER_PREFERENCE_KEY) === "true";

    if (shouldRemember && savedPreference === "continue") {
      orientationNotice.style.display = "none";
    }

    // 旋转屏幕按钮
    rotateButton?.addEventListener("click", async () => {
      if (rememberChoice.checked) {
        localStorage.setItem(ORIENTATION_PREFERENCE_KEY, "rotate");
        localStorage.setItem(REMEMBER_PREFERENCE_KEY, "true");
      }
      await lockScreenOrientation("landscape");
      orientationNotice.style.display = "none";
    });

    // 继续当前方向按钮
    continueButton?.addEventListener("click", () => {
      if (rememberChoice.checked) {
        localStorage.setItem(ORIENTATION_PREFERENCE_KEY, "continue");
        localStorage.setItem(REMEMBER_PREFERENCE_KEY, "true");
      }
      orientationNotice.style.display = "none";
    });

    // 监听方向变化，只显示建议
    const updateOrientation = () => {
      const currentOrientation = getDeviceOrientation();
      const targetOrientation =
        orientationNotice.getAttribute("data-orientation");

      // 如果用户选择了记住选择且选择继续，则不显示提示
      if (shouldRemember && savedPreference === "continue") {
        return;
      }

      // 只在竖屏时显示建议
      if (currentOrientation === targetOrientation) {
        orientationNotice.style.display = "flex";
      } else {
        orientationNotice.style.display = "none";
      }
    };

    // 初始检查
    updateOrientation();
    // 监听方向变化
    onOrientationChange(updateOrientation);
  }
</script>
